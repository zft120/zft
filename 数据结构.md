# 数据结构

## 队列

```cpp
#include <iostream>
#include <time.h>
using namespace std;

typedef struct Queue {
        int *data;
        int head, tail, size, cnt;
} Queue;

Queue *init(int n) {
        Queue *q = (Queue *)malloc(sizeof(Queue));
        q->data = (int *)malloc(sizeof(int) * n);
        q->head = q->tail = q->cnt = 0;
        q->size = n;
        return q;
}

int push(Queue *q, int val) {
        if (q == NULL) return 0;
        if (q->cnt == q->size) return 0;
        q->data[q->tail++] = val;
        if (q->tail == q->size) q->tail -= q->size;
        q->cnt += 1;
        return 1;
}

int empty(Queue *q) {
        return q->cnt == 0;
}

int pop(Queue *q) {
        if (q == NULL) return 0;
        if (empty(q)) return 0;
        q->head += 1;
        if (q->head == q->size) q->head -= q->size;
        q->cnt -= 1;
        return 1;
}

int front(Queue *q) {
        return q->data[q->head];
}

void clear(Queue *q) {
        if (q == NULL) return ;
        free(q->data);
        free(q);
        return ;
}

void output(Queue *q) {
        cout << "Queue(" << q->cnt << ") = [";
        for (int i = q->head, j = 0; j < q->cnt; j++) {
                if (j) cout << " ";
                cout << q->data[(i + j) % (q->size)];
        }
        cout << "]" << endl;
}

int main() {
        #define MAX_N 20
        Queue *q = init(2);
        srand(time(0));
        int op, val;
        for (int i = 0; i < MAX_N; i++) {
                op = rand() % 4;
                val = rand() % 1000;
                switch (op) {
                        case 0:
                        case 1:
                        case 2:
                                cout << "push " << val << " into Queue = " << push(q, val) << endl;
                                break;
                        case 3:
                                cout << "pop " << front(q) << "from  Queue = " << pop(q) << endl;
                                break;
                }
                output(q);
        }
        return 0;
}
```

## 栈

```cpp
#include <iostream>
using namespace std;

typedef struct Stack {
        int *data;
        int top, size;
} Stack;

Stack *init(int n) {
        Stack *s = (Stack *)malloc(sizeof(Stack));
        s->data = (int *)malloc(sizeof(int) * n);
        s->top = -1;
        s->size = n;
        return s;
}

int top(Stack *s) {
        if (s->top == -1) return 0;
        return s->data[s->top];
}

int empty(Stack *s) {
        return s->top == -1;
}

int expand(Stack *s) {
        int extr_size = s->size;
        int *p;
        while (extr_size) {
                p = (int *)realloc(s->data, sizeof(int) * (s->size + extr_size));
                if (p) break;
                extr_size /= 2;
        }
        if (p == NULL) return 0;
        s->size += extr_size;
        s->data = p;
        return 1;
}

int push(Stack *s, int val) {
        if (s == NULL) return 0;
        if (s->top + 1 == s->size) {
                if (!expand(s)) return 0;
                cout << "expand successfully!" << endl;
        }
        s->data[++(s->top)] = val;
        return 1;
}

int pop(Stack *s) {
        if (s == NULL) return 0;
        if (empty(s)) return 0;
        s->top -= 1;
        return 1;
}

void output(Stack *s) {
        cout << "Stack(" << s->top + 1 << ") = [";
        for (int i = 0; i <= s->top; i++) {
                if (i) cout << " ";
                cout << s->data[i];
        }
        cout << "]" << endl;
        return ;
}

void clear(Stack *s) {
        if (s == NULL) return ;
        free(s->data);
        free(s);
        return ;
}

int main() {
        srand(time(0));
        #define MAX_N 20
        Stack *s = init(MAX_N);
        int op, val;
        for (int i = 0 ;i < MAX_N; i++) {
                op = rand() % 4;
                val = rand() % 100;
                switch (op) {
                        case 0:
                        case 1:
                        case 2:
                                cout << "push " << val << " into Stack = " << push(s, val) << endl;
                                break;
                        case 3:
                                cout << "pop " << top(s) << "from Stack = " << pop(s) << endl;
                                break;
                }
                output(s);
        }
        clear(s);
        return 0;
}
```

